# SegM8 API (alternative version)

## `class SegM8`

Create an object of type `SegM8` to communicate with a chain of particular [SegM8 7-segment indicator modules](https://my.amperka.com/modules/SegM8).

### `SegM8(uint8_t pinCS)`

Constructs a new SegM8 object that uses the default hardware SPI bus.

- `pinCS`: the chip select (also known as slave select) pin is used to control the shift-register latch. It is marked `CS` on the SegM8 board. Any GPIO pin of the controller may be used.

### `SegM8(uint8_t pinCS, uint8_t pinDI, uint8_t pinCLK)`

Constructs a new SegM8 object that uses a software SPI bus.

- `pinCS`: the chip select (also known as slave select) pin is used to control the shift-register latch. It is marked `CS` on the SegM8 module. Any GPIO pin of the controller may be used.
- `pinDI`: the data input pin used to send data to the peripherals. It is marked `DI` on the SegM8 module. In SPI terms known as MOSI (Master Out Slave In). Any GPIO pin of the controller may be used.
- `pinCLK`: the clock pin is used to clock pulses that synchronize data transmission generated by the master. It is marked `CLK` on the SegM8 module. Also known as SCK in SPI terms. Any GPIO pin of the controller may be used.

The difference between hardware and software SPI is interaction speed. Software SPI runs slower than hardware SPI but hardware SPI works only on specific board pins: `MOSI`, `MISO` (not used in SegM8) and `SCK`.

### `void begin(FieldM8 fields)`

Initializes the given interface, prepares the board for the communication, and sets all module segments to the 'dark' state.
Call this method before interacting with SegM8. For example, in the `setup()`.

- `fields`: formatting field names separated by `|` or `+` in the order in which they are displayed.

### `void update()`

Copy field buffers to the daisy-chain of `SegM8` devices.


## `class FieldM8`

Create an object of type `FieldM8` that represents the formatted field on the `SegM8`.

### `FieldM8(uint8_t fieldWidth, uint8_t formatFlags = SEGM8_ALIGN_RIGHT | SEGM8_RADIX_10)`

Constructs a new FieldM8 object - formatted field.

- `fieldWidth`: formatted field width. `SegM8` devices in this field count.
- `formatFlags`: formatting flags specify formatting rules for this field.

Available formatting flags:
- `SEGM8_ALIGN_RIGHT` - align to right corner
- `SEGM8_ALIGN_LEFT` - align to left corner
- `SEGM8_PAD_ZEROS` - add leading zeros before the number. Compatible only with SEGM8_ALIGN_RIGHT and integer numbers.
- `SEGM8_RADIX_10` - use radix 10, only for unsigned int numbers.
- `SEGM8_RADIX_16` - use radix 16, only for unsigned int numbers.

### `friend const FieldM8 operator|(const FieldM8& left, const FieldM8& right)`
### `friend const FieldM8 operator+(const FieldM8& left, const FieldM8& right)`

A helper operator that allows you to link the fields in the desired order. Used in conjunction with SegM8::begin.

- `left` and `right`: fields to be connected

### `FieldM8& operator = (const int number)`
### `FieldM8& operator = (const unsigned int number)`
### `FieldM8& operator = (const long number)`
### `FieldM8& operator = (const double number)`

Prints `number` to formatted field buffer.

### `FieldM8& operator = (const char* line)`
### `FieldM8& operator = (const String line)`

Prints text `line` to formatted field buffer.

### `void custom(uint8_t mask)`

Displays a custom symbol in the specified field.
- `mask` - an 8-bit array. The ordinal number of the member of this array corresponds to the letter index of an indicator segment: 0 - a, 1 - b, <...>, 7 - h(dot). If field width more then 1 this `mask` is copied to all devices of field.

## Usage example:

```
SegM8 clock(PIN_CS);

FieldM8 hoursField(2);
FieldM8 delimiterField(1);
FieldM8 minutesField(2, SEGM8_ALIGN_RIGHT | SEGM8_PAD_ZEROS);

void setup() {
    clock.begin(hoursField | delimiterField | minutesField);

    hoursField = 0;
    delimiterField.custom(0x3); // custom ':'
    minutesField = 0;
}

void loop() {
    delay(60000);
    // reads external clock state here
    hoursField = readed.hour;
    minutesField = readed.min;
    clock.update();
}

```

### Пояснения по реализации (будут убраны из окончательного варианта API.md)

SegM8 - это просто контейнер, в нем есть указатель на цепочку полей. Этот контейнер умеет перебирая поля посылать данные из их буферов в реальный индикатор. 
FieldM8 - организованы как элементы списка, в каждом есть ссылка на следующий. Собираются в нужном порядке в список перегруженными операциями `|` или `+`, а в методе begin этот список прицепляется к SegM8.
Централизованого буфера нет. У каждого поля свой буфер заранее известного фиксированного размера.
Простой enum используется поскольку для разных параметров форматирования будет использован битовый шаблон: влево - 1, вправо - 0, лидирующие нули - 2, radix16 - 4, radix10 - 0.
