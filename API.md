# SegM8 API

## `class SegM8`

Create an object of type `SegM8` to communicate with a chain of particular [SegM8 7-segment indicator modules](https://my.amperka.com/modules/SegM8).

### `SegM8(uint8_t pinCS, uint8_t deviceCount = 1)`

Constructs a new SegM8 object that uses the default hardware SPI bus.

- `pinCS`: the chip select (also known as slave select) pin is used to control the shift-register latch. It is marked `CS` on the SegM8 board. Any GPIO pin of the controller may be used.
- `deviceCount`: the number of SegM8 modules connected in a daisy-chain. If omitted, defines a single module.

### `SegM8(uint8_t pinCS, uint8_t pinDI, uint8_t pinCLK, uint8_t deviceCount = 1)`

Constructs a new SegM8 object that uses a software SPI bus.

- `pinCS`: the chip select (also known as slave select) pin is used to control the shift-register latch. It is marked `CS` on the SegM8 module. Any GPIO pin of the controller may be used.
- `pinDI`: the data input pin used to send data to the peripherals. It is marked `DI` on the SegM8 module. In SPI terms known as MOSI (Master Out Slave In). Any GPIO pin of the controller may be used.
- `pinCLK`: the clock pin is used to clock pulses that synchronize data transmission generated by the master. It is marked `CLK` on the SegM8 module. Also known as SCK in SPI terms. Any GPIO pin of the controller may be used.
- `deviceCount`: the number of SegM8 modules connected in a daisy-chain. If omitted, defines a single module.

The difference between hardware and software SPI is interaction speed. Software SPI runs slower than hardware SPI but hardware SPI works only on specific board pins: `MOSI`, `MISO` (not used in SegM8) and `SCK`.

### `void begin()`

Initializes the given interface, prepares the board for the communication, and sets all module segments to the 'dark' state.
Call this method before interacting with SegM8. For example, in the `setup()`.

### `void display(int number, uint8_t position, uint8_t width, uint8_t flags = SEGM8_ALIGN_RIGHT)`
### `void display(unsigned int number, uint8_t position, uint8_t width, uint8_t flags = SEGM8_ALIGN_RIGHT + SEGM8_RADIX_10)`
### `void display(float number, uint8_t position, uint8_t width, uint8_t precission = 1, uint8_t flags = SEGM8_ALIGN_LEFT)`
### `void display(const char* string, uint8_t position, uint8_t width, uint8_t flags = SEGM8_ALIGN_LEFT)`
### `void display(String string, uint8_t position, uint8_t width, uint8_t flags = SEGM8_ALIGN_LEFT)`

Prints fixed `width` number or text line to the `position` of output buffer, using formatting `flags`.

- `number`: integer or floating point numbers.
- `string`: text line.
- `position`: start position of printed area.
- `width`: a segM8 modules count, needed for the number or text representation.
- `precission`: decimal places count of a float.
- `flags`: formatting flags. You can add somewhat consistent flags separated by `+` or `|` sign.

Available formatting flags:
- `SEGM8_ALIGN_RIGHT` - align to right corner
- `SEGM8_ALIGN_LEFT` - align to left corner
- `SEGM8_PAD_ZEROS` - add leading zeros before the number. Compatible only with SEGM8_ALIGN_RIGHT and integer numbers.
- `SEGM8_RADIX_10` - use radix 10, only for unsigned int numbers.
- `SEGM8_RADIX_16` - use radix 16, only for unsigned int numbers.

### `void writeSegments(uint8_t mask, uint8_t deviceIndex = 0)`

Displays a custom symbol in the specified position.
- `mask` - an 8-bit array. The ordinal number of the member of this array corresponds to the letter index of an indicator segment: 0 - a, 1 - b, <...>, 7 - h(dot).
- `deviceIndex` - A SegM8 device number in the daisy-chain. Can be in the range [0 : deviceCount-1].
