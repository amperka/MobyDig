# SegM8 API (RUS)

## `class SegM8`

Создайте объект типа `SegM8` для управления цепочкой [модулей 7-сегментных индикаторов SegM8](https://my.amperka.com/modules/SegM8).

### `SegM8(uint8_t pinCS, uint8_t deviceCount = 1)`

Создает новый объект SegM8, использующий Arduino hardware SPI интерфейс.

- `pinCS`: *chip select* (также известный как *slave select*) пин используется для управления защёлками сдвигового регистра. Помечен как **CS** на модуле SegM8. Можно использовать любой свободный пин контроллера.
- `deviceCount`: количество модулей SegM8, связанных в цепочку. Если не указано, принимается равным 1.

### `SegM8(uint8_t pinCS, uint8_t pinDI, uint8_t pinCLK, uint8_t deviceCount = 1)`

Создает новый объект SegM8, использующий Arduino software SPI интерфейс.

- `pinCS`: *chip select* (также известный как *slave select*) пин используется для управления защёлками сдвигового регистра. Помечен как **CS** на модуле SegM8. Можно использовать любой свободный пин контроллера.
- `pinDI`: *data input* — пин для передачи данных. Помечен как **DI** на модуле SegM8. В интерфейсе SPI соответствует **MOSI** (Master Out Slave In). Можно использовать любой свободный пин контроллера.
- `pinCLK`: *clock* — пин для передачи сигнала синхронизации данных. Помечен как **CLK** на модуле SegM8. Можно использовать любой свободный пин контроллера.
- `deviceCount`: количество модулей SegM8, связанных в цепочку. Если не указано, принимается равным 1.

Hardware и software SPI отличаются скоростью обмена данными. Software SPI работает медленнее, чем hardware SPI, однако hardware SPI работает исключительно на специальных пинах: **MOSI**, **MISO** (не используется SegM8) и **SCK**.

### `void begin()`

Инициализирует интерфейс, очищает внутренний буфер, устанавливает все сегменты в состояние «погашено».
Вызовите этот метод до начала взаимодействия с SegM8. Например в функции `setup()`.

### `void clear()`

Очищает все сегменты на модулях. Переводит их в состояние «погашено». Также очищает внутренний буфер.

### `void display(int number, uint8_t position, uint8_t width, uint8_t flags = SEGM8_ALIGN_RIGHT)`
### `void display(unsigned int number, uint8_t position, uint8_t width, uint8_t flags = SEGM8_ALIGN_RIGHT | SEGM8_RADIX_10)`
### `void display(long number, uint8_t position, uint8_t width, uint8_t flags = SEGM8_ALIGN_RIGHT)`
### `void display(unsigned long number, uint8_t position, uint8_t width, uint8_t flags = SEGM8_ALIGN_RIGHT | SEGM8_RADIX_10)`
### `void display(float number, uint8_t position, uint8_t width, uint8_t precission = 1, uint8_t flags = SEGM8_ALIGN_LEFT)`
### `void display(const char* string, uint8_t position, uint8_t width, uint8_t flags = SEGM8_ALIGN_LEFT)`
### `void display(String string, uint8_t position, uint8_t width, uint8_t flags = SEGM8_ALIGN_LEFT)`

Записывает число или текстовую строку, начиная с позиции `position`, шириной `width` знакомест во внутренний буфер. Форматирует его в соответствии с флагами `flags`. Затем выводит содержимое буфера в цепочку модулей. Замечание: знак `.` - точка - не занимает отдельного знакоместа при выводе, а выводится в предыдущем знакоместе.

При печати текстовых строк используется интерпретация символов в сегменты индикатора, для неподдерживаемых символов **K,M,N,V,W,X,Z** на индикаторе загорается самый верхний сегмент (сегмент **a**).

- `number`: число целое или с плавающей точкой.
- `string`: текстовая строка.
- `position`: начальная позиция вывода строки или числа во внутреннем буфере.
- `width`: количество элементов внутреннего буфера, и соответственно модулей SegM8, необходимых для размещения выводимой строки/числа.
- `precission`: количество знаков после запятой для float.
- `flags`: флаги форматирования. Можно добавить несколько, объединяя оператором `|`.

Доступные флаги форматирования:
- `SEGM8_ALIGN_RIGHT` — выровнить вправо, значение выравнивания по умолчанию.
- `SEGM8_ALIGN_LEFT` — выровнить влево.
- `SEGM8_PAD_ZEROS` — добавить лидирующие `0`. Флаг имеет смысл только для чисел, выравненных вправо.
- `SEGM8_RADIX_10` — использовать десятичную систему счисления. Значение по умолчанию.
- `SEGM8_RADIX_16` — использовать шестнадцатиричную систему. Флаг доступен только для беззнаковых целых чисел.

### `void writeSegments(uint8_t mask, uint8_t deviceIndex = 0)`

Отображает нестандартный символ в указанной позиции.
- `mask` — массив из 8 бит. Порядковый номер бита в массиве соответствует сегменту модуля: 0–a, 1–b, <...>, 7–h(dot).
- `deviceIndex` — порядковый номер модуля в цепочке устройств. Должен быть в пределах [0 : deviceCount−1].
